{"body":"# Event API spec\r\n\r\nThis is an attempt to specify a generic, but flexible way to log events\r\nin our codebase. There are two public APIs.\r\n\r\n## Public api\r\n\r\n### Recording events\r\n\r\nIn order to log an event, you need two things: the event name and the\r\ndata that it expects. Here's an example:\r\n\r\n```python\r\n# steadymark: ignore\r\n>>> from eventlib import log\r\n>>> log('app.EventName', {'username': 'test guy'})\r\n```\r\n\r\nThe event name above contains two very important pieces of information\r\nabout the event: the app and the class name that inherits from\r\n`BaseEvent`. It is _required_ to declare your events in a module called\r\n`events` inside the app folder. We will go deeper into it in the next\r\nsection.\r\n\r\nIf, by any chance, you try to access an event that does not exist, a\r\ncustom exception should be raised, stating exactly what happened:\r\n\r\n```python\r\n>>> # inside the event/log.py\r\n>>> class EventNotFound(Exception):\r\n...     pass\r\n...\r\n>>> def _get_event(name):\r\n...     app, event_name = _parse_event_name(name)\r\n...     if name not in get_events():\r\n...         raise EventNotFound(\r\n...             'There is no event named {} in the {} app'.format(\r\n...                 event_name, app\r\n...             )\r\n...         )\r\n```\r\n\r\n### Declaring an event\r\n\r\nThis is a three step process.\r\n\r\n 1. Declare an event object\r\n 1. Optionally provide a component to validate the data received by this\r\n    event.\r\n 1. Describe the handlers.\r\n\r\n So, we end up with something like this:\r\n<pre>\r\n         -------------\r\n        | event class |\r\n         -------------\r\n               |\r\n              / \\\r\n      optional   handlers\r\n     validator\r\n</pre>\r\n\r\nDeclaring an event should be as simple as the following example:\r\n\r\n```python\r\n>>> from eventlib import BaseEvent\r\n>>> class DealClick(BaseEvent):\r\n...     pass\r\n```\r\n\r\nThis is the only required step to declare an event. But, our event won't\r\ngo anywhere without `handlers`. We use them to declare the actions that\r\nthe event will actually trigger. Writing to a database, making an http\r\ncall or executing a celery task are some examples of actions that can be\r\ndeclared in a handler.\r\n\r\nThe first way to add a handler to an event is by adding a decorated\r\nmethod to your event class. Like this:\r\n\r\n```python\r\n>>> import eventlib\r\n>>> import eventlib.core\r\n>>> class EmailClick(eventlib.BaseEvent):\r\n...     @eventlib.handler\r\n...     def increment_redis_key(self):\r\n...         key = 'deal:{}:clicks'.format(self.data.get('key'))\r\n...         self.redis(key).incr()\r\n...\r\n...     @eventlib.handler\r\n...     def save_to_mysql(self):\r\n...         data = self.data.copy()\r\n...         data.pop('unused_key')\r\n...         self.mysql('apps.EmailClick').save(**data)\r\n...\r\n>>> eventlib.core.HANDLER_REGISTRY[EmailClick]\r\n[<unbound method EmailClick.save_to_mysql>, <unbound method EmailClick.increment_redis_key>]\r\n```\r\n\r\nBut if you are in a scenario where functions will fit your needs better,\r\nlike when you need to declare a handler in another module, you can do\r\nsomething like this:\r\n\r\n```python\r\n>>> import eventlib\r\n>>>\r\n>>> @eventlib.handler('api.ApiCall')\r\n... def call_3rd_party_api(event):\r\n...     api_key = event.data('api_key')\r\n...     res = requests.get(settings.THIRDPARTYAPI_URL.format(api_key))\r\n...     User.objects.filter(email=res.content).update(discount=99)\r\n```\r\n\r\nPlease notice that handlers declared as methods will always be called\r\n*before* the function based handlers.\r\n\r\n### Data validation\r\n\r\nEvents are added to a queue before being processed. It's a long road\r\nfrom calling the `log()` function to actually using the data passed to\r\nit. So, instead of allowing the log processor to start all the steps of\r\nserialization, sending, deserialization and so on, this API provides a\r\nway to validate the data that the log expects. This validation will be\r\ncalled when the task runs. Here's the way to validate your event's data:\r\n\r\n```python\r\n>>> import eventlib\r\n>>> class MyEvent(eventlib.BaseEvent):\r\n...     def clean(self):\r\n...         required_keys = 'deal_id', 'user_id', 'code'\r\n...         missing_keys = []\r\n...         for key in required_keys:\r\n...             if not key in self.data:\r\n...                 missing_keys.append(key)\r\n...         if missing_keys:\r\n...             raise eventlib.ValidationError(\r\n...                 'The following keys are missing: {}'.format(\r\n...                     ', '.join(missing_keys)))\r\n```\r\n\r\nThere's also a helper for this very common case:\r\n\r\n```python\r\n>>> def clean(self):\r\n...    # This call will raise the ValidationError if any of these\r\n...    # keys are missing\r\n...    self.require_data_keys(['deal_id', 'user_id', 'code'])\r\n```\r\n\r\nBehind the scenes, things are something like this:\r\n\r\n```python\r\n>>> def log(name, data):\r\n...     event = special_import(name)()\r\n...     try:\r\n...         data = event.clean(data)\r\n...     except ValidationError:\r\n...         log_to_sentry.error(\"Invalid Data Passed to blah from foo\")\r\n...     else:\r\n...         delay_event(event, data)\r\n```\r\n\r\n## Params that events can take\r\n\r\nEvents can take any kind of parameter serializable by the `json.dumps`\r\nfunction. If you are willing to pass parameters that are not supported\r\nby this library by default, you will need to refer to the\r\n[extensible-serialization](https://github.com/Yipit/eventlib/blob/master/docs/extensible-serialization.md)\r\ndocument.\r\n\r\n## Events are not immediately processed\r\n\r\nAs we don't want to compromise the performance of our main application\r\nwith something secondary like logging, this spec also demands that all\r\nlogging should run in separate tasks dispatched through celery.\r\n\r\nThe flow is like this:\r\n\r\n<pre>\r\n     ---------------------\r\n    | eventlib.log() call |\r\n     ---------------------\r\n         \\ -----------------\r\n          | serialize(data) |\r\n           -----------------\r\n                \\ ----------------------\r\n                 | log_processing.delay |\r\n                / ----------------------\r\n           -------------------\r\n          | deserialize(data) |\r\n         / -------------------\r\n     ------------------------\r\n    | eventlib.process(data) |\r\n     ------------------------\r\n</pre>\r\n\r\n### Handlers should fail gracefully\r\n\r\nThere can be a list of different handlers to execute in the same event\r\nprocessing and we must ensure that if one of these handlers fail, the\r\nother ones will have their chance to try. This way, the `process()`\r\nfunctions should iterate over all registered handlers for that event\r\ntaking care to handle any error _and_ log it with the default python\r\n`logging` module. Something like this:\r\n\r\n```\r\n>>> handlers = self.registered_handlers()\r\n... for h in handlers:\r\n...     try:\r\n...         h(deserialized_data)\r\n...     except:\r\n...         log_to_sentry()\r\n```\r\n\r\n## JavaScript API\r\n\r\nIf you are a front end developer and are afraid that you would be out of\r\nthe new event sensation, don't worry! We've got JavaScript\r\n\r\nThere's an HTTP view that wraps the `event.log()` call. On top of this\r\nfunction, we have the `yipit.event.log()` JS function that works exactly\r\nlike the python version.\r\n\r\nBehind this JavaScript call, there's an ajax call in the following\r\nformat:\r\n\r\n    POST /event/log?__event__=app.EventName&param1=val1&param2=val2\r\n\r\nThe view will parse the query string and build something like this:\r\n\r\n```python\r\n>>> event_name = 'app.EventName'\r\n>>> data = {'param1': 'val1', 'param2': 'val2'}\r\n```\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Async event management","google":"","name":"Eventlib"}